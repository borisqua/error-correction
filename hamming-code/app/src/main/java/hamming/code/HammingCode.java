/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hamming.code;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Scanner;
import java.util.List;
import java.util.Random;
import java.util.function.BiConsumer;
import java.util.function.Function;

public class HammingCode {
    
    private static final Random rnd = new Random(System.currentTimeMillis() % 1223);

    private static final Scanner scanner = new Scanner(System.in);
    
    private static final int[] parityMasks = {
        0x55, // position number's 0th bit set -> 1 11 101 111 ... - 1  3  5  7 ...
        0x33, // position number's 1th bit set -> 10 11 110 111 ... - 2 3  6 7 ...
        0x0f // position number's 2th bit set -> 100 101 110 111 1(1)00 ... - 4 5 6 7  12 13 14 15
    };
    
    private static final Function<Function<byte[], byte[]>, BiConsumer<String, String>>
        doConversion = conversion -> (inputFile, outputFile) -> {
        try {
            Files.write(Path.of(outputFile), conversion.apply(Files.readAllBytes(Path.of(inputFile))));
        } catch (IOException e) {
            e.printStackTrace();
        }
    };
    
    private static final Function<Integer, Integer> parity = n -> // works only for bytes <= 127
        (byte) (((n * 0x0101010101010101L) & 0x8040201008040201L) % 0x1FF) & 1; // T(4)
    // anyway fastest in most cases is precalculated parities array -> O(1)
    
    public static void main(String[] args) throws IOException {

//    String command = scanner.next();
        List<String> processCommands = List.of("encode", "send", "decode");

        System.out.println();
        System.out.println("\noriginal text to send: \n");
        System.out.println(new String(Files.readAllBytes(Path.of("send.txt"))));
        System.out.println();
        
        for (String command : processCommands) {
            
            System.out.print("Next operation: "); // to use with Scanner
            System.out.println(command);
            System.out.println("Press enter to proceed");
            scanner.nextLine();
            
            switch (command) {
                case "encode":
                    doConversion
                        .apply(HammingCode::encode)
                        .accept("send.txt", "encoded.txt");
                    break;
                
                case "send":
                    doConversion
                        .apply(HammingCode::simulateSendErrors)
                        .accept("encoded.txt", "received.txt");
                    break;
                
                case "decode":
                    doConversion
                        .apply(HammingCode::decode)
                        .accept("received.txt", "decoded.txt");
            }
        }
        
    }
    
    private static byte getHammingCode4(byte input) { //4 data bit encoded as 1 error protected byte
        byte code = 0;
        int data1 = input & 0b1000;
        int data2 = input & 0b0111;
        code |= data1 << 2;
        code |= data2 << 1;
        
        // add redundant parity bits
        for (byte i = 0; i < 3; i++) {
//      int parityBit = Integer.bitCount(code >>> 1 & parityMasks[i]) & 1; //using standard java bit counting
            int parityBit = parity.apply(code >>> 1 & parityMasks[i]); //alternative parity
            code |= parityBit << (8 - (1 << i)); // 1<<s - position
        }
        return code;
    }
    
    private static long getHammingCode32(int dataSize, int input) {
        
        byte result = 0;
        
        //2^r >= r + dataSize + 1 => r <= 2^r - 1 - dataSize
        int redundancy = 0;
        while (1 << redundancy - 1 - dataSize < redundancy) {
            redundancy++;
        }
        
        // store data bits into code
        int dataBitsProcessed = 0;
        for (int i = redundancy - 1; i > 0; i--) { // calculating Hamming code (7/4) - three additional bits
            int position = 1 << i;
            int nextDataBitsLength = position - 1;
            
            // select next data bits
            long dataBits = input >>> dataBitsProcessed;
            dataBits = (dataBits << (8 - nextDataBitsLength)) >>> (8 - nextDataBitsLength);
            
            result |= dataBits << (8 - position - nextDataBitsLength);
            dataBitsProcessed += nextDataBitsLength;
        }
        
        // add redundant parity bits
        for (int i = 0; i < redundancy; i++) {
//      int parityBit = Integer.bitCount(result >>> 1 & parityMasks[i]) & 1;
            int parityBit = parity.apply(result >>> 1 & parityMasks[i]); //alternative parity
            result |= parityBit << (8 - (1 << i)); // 1<<s - position
        }
        
        return result;
    }
    
    private static byte getHammingData(byte code) {
        
        byte result = 0;
        int wrongBit = 0;
        
        //check parities
        for (int i = 0; i < 3; i++) {
            int parity = Integer.bitCount(code >>> 1 & parityMasks[i]) & 1;
//      int parityBit = parity.apply(code >>> 1 & parityMasks[i]); //alternative parity
            if (parity == 1) {
                wrongBit += 1 << i;
            }
        }
        
        code ^= 1 << 8 - wrongBit;
        
        result |= ((code & 0b00001110) >>> 1) & 0b111;
        result |= ((code & 0b00100000) >>> 2) & 0b1111;
        
        return result;
    }
    
    private static byte getHammingData32(int dataSize, int code) {
        
        byte result = 0;
        int wrongBit = 0;
        
        //check parities
        for (int i = 0; i < 3; i++) {
            int parity = Integer.bitCount(code >>> 1 & parityMasks[i]) & 1;
            if (parity == 1) {
                wrongBit += 1 << i;
            }
        }
        
        code ^= 1 << 8 - wrongBit;
        
        // retrieve data bits from hamming code
        for (byte i = 2; i > 0; i--) { // calculating Hamming code (7/4) - three additional bits
            int position = 1 << i;
            int nextDataBitsLength = position - 1;
            int dataBitsMask = (1 << nextDataBitsLength) - 1;
            int shift = 8 - position - nextDataBitsLength;
            
            // select next data bits
            int dataBits = code >>> shift & dataBitsMask;
            result |= dataBits;
        }
        
        return result;
    }
    
    private static byte[] encode(byte[] bytes) {
        
        System.out.println("text in hex: " + stringOfBytes(bytes, "hex", " ", 2));
        System.out.println();
        System.out.println("text in bin: " + stringOfBytes(bytes, "bin", " ", 8));
        System.out.println();
        
        byte[] encodedBytes = new byte[bytes.length * 2];
        
        for (int i = 0; i < bytes.length; i++) {
            encodedBytes[i * 2] = getHammingCode4((byte) ((bytes[i] & 0b11110000) >>> 4));
            encodedBytes[i * 2 + 1] = getHammingCode4((byte) (bytes[i] & 0b1111));
//      encodedBytes[i * 2] = (byte) getHammingCode32(4, (bytes[i] & 0b11110000) >>> 4);
//      encodedBytes[i * 2 + 1] = (byte) getHammingCode32(4, bytes[i] & 0b1111);
        }
        
        System.out.println("encoded with protection information");
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(encodedBytes, "hex", " ", 2));
        System.out.println();
        
        return encodedBytes;
    }
    
    private static byte[] simulateSendErrors(byte[] bytes) { // send (transmission simulation)
        
        System.out.println("encoded before transmission");
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(bytes, "hex", " ", 2));
        System.out.println();
        System.out.println("in bin: " + stringOfBytes(bytes, "bin", " ", 8));
        System.out.println();
        
        for (int i = 0; i < bytes.length; i++) {
            int bitPosition = rnd.nextInt(7);
            bytes[i] ^= 1 << bitPosition;
        }
        
        System.out.println("encoded with distortion after transmission");
        System.out.println();
        System.out.println("in bin: " + stringOfBytes(bytes, "bin", " ", 8));
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(bytes, "hex", " ", 2));
        System.out.println();
        System.out.println("text is distorted: " + new String(bytes));
        System.out.println();
        return bytes;
        
    }
    
    private static byte[] decode(byte[] bytes) {
        
        byte[] decoded = new byte[bytes.length / 2];
        
        System.out.println("text is distorted after transmission: " + new String(bytes));
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(bytes, "hex", " ", 2));
        System.out.println();
        System.out.println("in bin: " + stringOfBytes(bytes, "bin", " ", 8));
        System.out.println();
        
        for (int i = 0; i < decoded.length; i++) {
            decoded[i] = (byte) (getHammingData(bytes[i * 2]) << 4);
            decoded[i] |= getHammingData(bytes[i * 2 + 1]);
//      decoded[i] = (byte) getHammingData32(4, (int) bytes[i * 2] << 4);
//      decoded[i] = (byte) getHammingData32(4, (int) bytes[i * 2 + 1]);
        }
        
        System.out.println("correcting using Hamming code");
        System.out.println();
        System.out.println("corrected in bin: " + stringOfBytes(bytes, "bin", " ", 8));
        System.out.println();
        System.out.println("corrected in hex: " + stringOfBytes(bytes, "hex", " ", 2));
        System.out.println();
        System.out.println("decoded: " + stringOfBytes(decoded, "bin", " ", 8));
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(decoded, "hex", " ", 2));
        System.out.println();

//    decoded = Arrays.copyOf(decoded, notEmptyCount);
//    System.out.println("removed: " + stringOfBytes(decoded, "hex", " ", 2));
        
        System.out.println("\nrepaired text: \n\n" + new String(decoded));
        System.out.println();
        
        return decoded;
        
    }
    
    private static String unsignedByteBinaryString(int field) {
        if (field < 0) {
            field = ((field << 24) >>> 24) | 0b1000_0000;
        }
        return String.format("%08d", Integer.parseInt(Integer.toBinaryString(field)));
    }
    
    private static String unsignedByteHexString(int field) {
        if (field < 0) {
            field = ((field << 24) >>> 24) | 0b1000_0000;
        }
        return String.format("%02x", field);
    }
    
    private static char[] doublingChars(char[] chars) {
        char[] result = new char[chars.length * 2];
        for (int i = 0; i < chars.length; i++) {
            result[i * 2] = (result[i * 2 + 1] = chars[i]);
        }
        return result;
    }
    
    @SuppressWarnings("SameParameterValue")
    private static String stringOfBytes(byte[] bytes, String type, String splitter, int groupSize) {
        StringBuilder resultChars = new StringBuilder();
        for (int aByte : bytes) {
            switch (type.toLowerCase()) {
                
                case "hex":
                    resultChars.append(unsignedByteHexString(aByte));
                    break;
                
                case "bin":
                    resultChars.append(unsignedByteBinaryString(aByte));
                    break;
                
                case "bit-doubling":
                    resultChars.append(doublingChars(unsignedByteBinaryString(aByte).toCharArray()));
                
            }
        }
        
        for (int i = 0; i < resultChars.length() - groupSize; i += groupSize) { // splitting
            resultChars.insert(i + groupSize, splitter);
            i += splitter.length();
        }
        
        return resultChars.toString();
    }
    
    @SuppressWarnings("unused")
    private static String bin(int i) {
        return unsignedByteBinaryString(i);
    }
    
}
