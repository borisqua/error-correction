/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package triplets;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.Scanner;
import java.util.function.BiConsumer;
import java.util.function.Function;

public class TripletsCode {
    
    private static final Random rnd = new Random(System.currentTimeMillis() % 1223);
    
    private static final Scanner scanner = new Scanner(System.in);
    
    private static final Function<Function<byte[], byte[]>, BiConsumer<String, String>>
        doConversion = conversion -> (inputFile, outputFile) -> {
        try {
            Files.write(Path.of(outputFile), conversion.apply(Files.readAllBytes(Path.of(inputFile))));
        } catch (IOException e) {
            e.printStackTrace();
        }
    };
    
    public static void main(String[] args) throws IOException {

//    String command = scanner.next();
        List<String> processCommands = List.of("encode", "send", "decode");
        
        System.out.println();
        System.out.println("\noriginal text to send: \n");
        System.out.println(new String(Files.readAllBytes(Path.of("send.txt"))));
        System.out.println();
        
        for (String command : processCommands) {
    
            System.out.print("Next operation: "); // to use with Scanner
            System.out.println(command);
            System.out.println("Press enter to proceed");
            scanner.nextLine();
            
            switch (command) {
                case "encode":
                    doConversion
                        .apply(TripletsCode::encode)
                        .accept("send.txt", "encoded.txt");
                    break;
                
                case "send":
                    doConversion
                        .apply(TripletsCode::simulateSendErrors)
                        .accept("encoded.txt", "received.txt");
                    break;
                
                case "decode":
                    doConversion
                        .apply(TripletsCode::decode)
                        .accept("received.txt", "decoded.txt");
            }
        }
        
    }
    
    private static byte[] encode(byte[] bytes) { // encode
        
        System.out.println("text in hex: " + stringOfBytes(bytes, "hex", " ", 2));
        System.out.println();
        System.out.println("text in bin: " + stringOfBytes(bytes, "bin", " ", 8));
        System.out.println();
        
        int bits = bytes.length * 8;
        byte[] tripletsOfBits = new byte[(int) Math.ceil((double) bits / 3)];
        int[] tripletsOfBytes = new int[(int) Math.ceil((double) bytes.length / 3)];
        
        for (int i = 0; i < tripletsOfBytes.length; i++) {
            int shift = 16; // first shift on 2 bytes
            for (int j = 0; j < 3; j++) {
                if (i * 3 + j >= bytes.length) {
                    break;
                }
                tripletsOfBytes[i] |= bytes[i * 3 + j] << shift;
                shift -= 8; // decrease next shift on 1 byte
            }
        }
        for (int i = 0; i < tripletsOfBytes.length; i++) {
            int tripletShift = 24;
            for (int j = 0; j < 8; j++) {
                tripletShift -= 3;
                int triplet = (tripletsOfBytes[i] >>> tripletShift) & 7;
                int parity = ((triplet & 4) >> 2) ^ ((triplet & 2) >> 1) ^ (triplet & 1);
                triplet = (triplet << 1) | parity;
                
                int bitToMovePosition = 0b1_0000;
                int bitShift = 4;
                do {
                    
                    bitToMovePosition /= 2;
                    
                    int bitToMove = triplet & bitToMovePosition;
                    int movedBits = bitToMove << bitShift | bitToMove << bitShift - 1;
                    int bitsToZero = 255 ^ bitToMove;
                    triplet &= bitsToZero; //set moved bits to zero
                    triplet |= movedBits; // move
                    
                    bitShift--;
                    
                } while (bitToMovePosition > 1);
                
                if (i * 8 + j >= tripletsOfBits.length) {
                    break;
                }
                tripletsOfBits[i * 8 + j] = (byte) triplet;
                
            }
        }
        
        System.out.println("encoded with protection information");
        System.out.println();
        System.out.println("expanded: " + stringOfBytes(bytes, "bit-doubling", ".. ", 6));
        System.out.println();
        System.out.println("with parity bits: " + stringOfBytes(tripletsOfBits, "bin", " ", 8));
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(tripletsOfBits, "hex", " ", 2));
        System.out.println();
        
        return tripletsOfBits;
        
    }
    
    private static byte[] simulateSendErrors(byte[] bytes) { // send (transmission simulation)
        
        System.out.println("encoded with protection information");
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(bytes, "hex", " ", 2));
        System.out.println();
        System.out.println("in bin: " + stringOfBytes(bytes, "bin", " ", 8));
        System.out.println();
        
        for (int i = 0; i < bytes.length; i++) {
            int bitPosition = rnd.nextInt(7);
            bytes[i] ^= 1 << bitPosition;
        }
        
        System.out.println("encoded with distortion after transmission");
        System.out.println();
        System.out.println("in bin: " + stringOfBytes(bytes, "bin", " ", 8));
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(bytes, "hex", " ", 2));
        System.out.println();
        System.out.println("text is distorted: \n" + new String(bytes));
        System.out.println();
        return bytes;
        
    }
    
    private static byte[] decode(byte[] bytes) {
        
        int[] tripletsOfBytes = new int[(int) Math.ceil((float) bytes.length / 8)];
        byte[] decoded = new byte[(int) Math.ceil((float) bytes.length * 3 / 8)];
        
        System.out.println("text is distorted after transmission: \n" + new String(bytes));
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(bytes, "hex", " ", 2));
        System.out.println();
        System.out.println("in bin: " + stringOfBytes(bytes, "bin", " ", 8));
        System.out.println();
        
        int tripletIndex = 0;
        int inTripletShift = 21; //todo?? can be replaced by (21 - (22 + tripletIndex) % 22) but is it worth it?
        
        System.out.println("correcting using parity in bit triplets");
        System.out.println();
        
        for (int b = 0; b < bytes.length; b++) {
            
            int parity = 0;
            int bitShift = 7;
            int bitPosition = 0b1000_0000;
            int brokenBit = -1;
            for (int pair = 3; pair > 0; pair--) { // 1. is there a broken pair of data bits?
                int bit1 = (bytes[b] & bitPosition) >>> bitShift;
                bitShift--;
                bitPosition /= 2;
                int bit2 = (bytes[b] & bitPosition) >>> bitShift;
                bitShift--;
                bitPosition /= 2;
                if (bit1 == bit2) {
                    parity = parity ^ bit1;
                    
                } else {
                    brokenBit = pair;
                }
                
            }
            
            if (brokenBit > 0) { // 2. broken bit is (parity bit) xor (xor of rest 2 bits)
                int repairedBit = parity ^ (bytes[b] & 1);
                
                // clear bits
                bytes[b] = (byte) (bytes[b] & ~(1 << (brokenBit * 2 + 1)));
                bytes[b] = (byte) (bytes[b] & ~(1 << (brokenBit * 2)));
                
                // repair bit
                bytes[b] = (byte) (bytes[b] | (repairedBit << (brokenBit * 2 + 1)));
                bytes[b] = (byte) (bytes[b] | (repairedBit << (brokenBit * 2)));
                
            } else {
                bytes[b] = (byte) (bytes[b] & ~3 | (parity << 1) | parity); // repair parity bits if broken
            }
            
            tripletsOfBytes[tripletIndex] |= (((bytes[b] & 64) >>> 4) | ((bytes[b] & 16) >>> 3) | ((bytes[b] & 4) >>> 2)) << inTripletShift;
            inTripletShift -= 3; //todo?? can be replaced by (21 - (22 + tripletIndex) % 22) but is it forth it?
            if (inTripletShift < 0) {
                tripletIndex++;
                inTripletShift = 21;
            }
            
        }
        
        int notEmptyCount = 0;
        for (int t = 0; t < tripletsOfBytes.length; t++) {
            int byteShift = 16;
            for (int d = 0; d < 3; d++) {
                int decodedIndex = t * 3 + d;
                if (decodedIndex >= decoded.length) {
                    break;
                }
                decoded[decodedIndex] = (byte) (tripletsOfBytes[t] >>> byteShift);
                if (decoded[decodedIndex] != 0) {
                    notEmptyCount++;
                }
                byteShift -= 8;
            }
        }
        
        System.out.println("corrected in bin: " + stringOfBytes(bytes, "bin", " ", 8));
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(bytes, "hex", " ", 2));
        System.out.println();
        System.out.println("decoded: " + stringOfBytes(decoded, "bin", " ", 8));
        System.out.println();
        System.out.println("in hex: " + stringOfBytes(decoded, "hex", " ", 2));
        System.out.println();
        
        decoded = Arrays.copyOf(decoded, notEmptyCount);
        System.out.println("removed empty space after correcting code: " + stringOfBytes(decoded, "hex", " ", 2));
        
        System.out.println("\nrepaired text: \n\n" + new String(decoded));
        System.out.println();
        
        return decoded;
        
    }
    
    private static String unsignedByteBinaryString(int field) {
        if (field < 0) {
            field = ((field << 24) >>> 24) | 0b1000_0000;
        }
        return String.format("%08d", Integer.parseInt(Integer.toBinaryString(field)));
    }
    
    private static String unsignedByteHexString(int field) {
        if (field < 0) {
            field = ((field << 24) >>> 24) | 0b1000_0000;
        }
        return String.format("%02x", field);
    }
    
    private static char[] doublingChars(char[] chars) {
        char[] result = new char[chars.length * 2];
        for (int i = 0; i < chars.length; i++) {
            result[i * 2] = (result[i * 2 + 1] = chars[i]);
        }
        return result;
    }
    
    private static String stringOfBytes(byte[] bytes, String type, String splitter, int groupSize) {
        StringBuilder resultChars = new StringBuilder();
        for (int aByte : bytes) {
            switch (type.toLowerCase()) {
                
                case "hex":
                    resultChars.append(unsignedByteHexString(aByte));
                    break;
                
                case "bin":
                    resultChars.append(unsignedByteBinaryString(aByte));
                    break;
                
                case "bit-doubling":
                    resultChars.append(doublingChars(unsignedByteBinaryString(aByte).toCharArray()));
                
            }
        }
        
        for (int i = 0; i < resultChars.length() - groupSize; i += groupSize) { // splitting
            resultChars.insert(i + groupSize, splitter);
            i += splitter.length();
        }
        
        return resultChars.toString();
    }
    
    @SuppressWarnings("unused")
    public static String bin(int i) {
        return unsignedByteBinaryString(i);
    }
    
}
